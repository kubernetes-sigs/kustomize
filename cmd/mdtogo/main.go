// Copyright 2019 The Kubernetes Authors.
// SPDX-License-Identifier: Apache-2.0

// Package main generates cobra.Command go variables containing documentation read from .md files.
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var full bool

func main() {
	for _, a := range os.Args {
		if a == "--full=true" {
			full = true
		}
	}

	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "requires source dir and dest dir as args\n")
		os.Exit(1)
	}
	source := os.Args[1]
	dest := os.Args[2]

	files, err := ioutil.ReadDir(source)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}

	var docs []Doc
	for _, f := range files {
		if filepath.Ext(f.Name()) != ".md" {
			continue
		}
		b, err := ioutil.ReadFile(filepath.Join(source, f.Name()))
		if err != nil {
			fmt.Fprintf(os.Stderr, "%v\n", err)
			os.Exit(1)
		}

		docs = append(docs, parse(f.Name(), string(b)))
	}

	out := []string{`// Copyright 2019 The Kubernetes Authors.
// SPDX-License-Identifier: Apache-2.0

// Code generated by "mdtogo"; DO NOT EDIT.
package ` + filepath.Base(dest) + "\n"}

	for i := range docs {
		out = append(out, docs[i].String())
	}

	if _, err := os.Stat(dest); err != nil {
		_ = os.Mkdir(dest, 0700)
	}

	o := strings.Join(out, "\n")
	err = ioutil.WriteFile(filepath.Join(dest, "docs.go"), []byte(o), 0600)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func parse(name, value string) Doc {
	name = strings.ReplaceAll(name, filepath.Ext(name), "")
	name = strings.Title(name)
	name = strings.ReplaceAll(name, "-", "")

	scanner := bufio.NewScanner(bytes.NewBufferString(value))

	var long, examples []string
	var short string
	var isLong, isExample, isIndent bool
	var doc Doc

	for scanner.Scan() {
		line := scanner.Text()

		if strings.HasPrefix(line, "## ") && short == "" {
			for scanner.Scan() {
				if strings.TrimSpace(scanner.Text()) == "" {
					continue
				}
				short = scanner.Text()
				break
			}
			continue
		}

		if !full {
			if strings.HasPrefix(line, "### Synopsis") {
				isLong = true
				isExample = false
				continue
			}

			if strings.HasPrefix(line, "### Examples") {
				isLong = false
				isExample = true
				continue
			}

			if strings.HasPrefix(line, "### ") {
				isLong = false
				isExample = false
				continue
			}
		}

		if strings.HasPrefix(line, "```") {
			isIndent = !isIndent
			continue
		}
		line = strings.ReplaceAll(line, "`", "` + \"`\" + `")
		if isIndent {
			line = "\t" + line
		}

		if isLong || full {
			long = append(long, line)
			continue
		}
		if isExample {
			examples = append(examples, line)
		}
	}

	doc.Name = name
	doc.Short = short
	doc.Long = strings.Join(long, "\n")
	doc.Examples = strings.Join(examples, "\n")

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	return doc
}

type Doc struct {
	Name     string
	Short    string
	Long     string
	Examples string
}

func (d Doc) String() string {
	var parts []string

	if d.Short != "" {
		parts = append(parts,
			fmt.Sprintf("var %sShort=`%s`", d.Name, d.Short))
	}
	if d.Long != "" {
		parts = append(parts,
			fmt.Sprintf("var %sLong=`%s`", d.Name, d.Long))
	}
	if d.Examples != "" {
		parts = append(parts,
			fmt.Sprintf("var %sExamples=`%s`", d.Name, d.Examples))
	}

	return strings.Join(parts, "\n") + "\n"
}
